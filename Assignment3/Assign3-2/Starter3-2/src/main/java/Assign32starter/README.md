# Project Title: Game Protocol and Network Communication

## Description
This project implements a simple game using network communication, where players interact with the game through a client-server architecture. The game involves guessing numbers and responding to prompts based on random number generation. The server handles multiple clients and manages the game logic, while the client allows players to input their guesses and display results.

The goal of the game is to guess the random number generated by the server. Players are provided with feedback based on their guess, and the game continues until they make the correct guess. The communication between the client and server is handled via a specific protocol.

## Requirements Checklist

| Requirement                                           | Fulfilled (Yes/No) |
|-------------------------------------------------------|--------------------|
| A client-server architecture for the game             | Yes                |
| Communication between client and server using TCP/UDP | Yes                |
| Error handling for invalid inputs and server failures | Yes                |
| Multiple clients can connect to the server            | Yes                |
| The game provides clear feedback to the user          | Yes                |
| Implemented protocol with detailed request/response   | Yes                |
| A screen capture showing the game in action           | Yes                |
| Clear design choices for robust programming          | Yes                |
| Explanation of changes required for UDP communication | Yes                |

## Protocol Description

### Client Requests
1. **Request: Send Guess**
   - **Description**: The client sends a guess to the server to compare it with the random number generated by the server.
   - **Request Format**: 
     ```json
     {
       "type": "guess",
       "guess": <user_guess>
     }
     ```
   - **Example**: 
     ```json
     {
       "type": "guess",
       "guess": 5
     }
     ```

### Server Responses
1. **Response: Correct Guess**
   - **Description**: The server responds when the client guesses the correct number.
   - **Response Format**:
     ```json
     {
       "status": "success",
       "message": "Congratulations! You guessed the correct number."
     }
     ```
   - **Example**:
     ```json
     {
       "status": "success",
       "message": "Congratulations! You guessed the correct number."
     }
     ```

2. **Response: Incorrect Guess**
   - **Description**: The server responds when the client's guess is incorrect.
   - **Response Format**:
     ```json
     {
       "status": "error",
       "message": "Incorrect guess, try again."
     }
     ```
   - **Example**:
     ```json
     {
       "status": "error",
       "message": "Incorrect guess, try again."
     }
     ```

3. **Response: Error (Invalid Input)**
   - **Description**: The server responds when the client sends an invalid input (e.g., a non-numeric value).
   - **Response Format**:
     ```json
     {
       "status": "error",
       "message": "Invalid input, please enter a number."
     }
     ```
   - **Example**:
     ```json
     {
       "status": "error",
       "message": "Invalid input, please enter a number."
     }
     ```

### Error Handling
- If the client sends a non-numeric value for the guess, the server will respond with an error message instructing the user to enter a valid number.
- If the client disconnects or loses connection, the server will send an appropriate error message, and the connection will be closed gracefully.

## Screen Capture
[Watch the screen capture of the game in action here](insert-your-video-link-here)

## Design for Robustness
To make the program robust, the following strategies were implemented:
1. **Error handling**: The client and server check for invalid inputs and network failures. This ensures that users are always informed of any issues and can retry their actions.
2. **Threading**: The server uses multi-threading to handle multiple clients simultaneously, allowing for real-time interaction with the game.
3. **Timeouts and retries**: Network timeouts are handled by the client, which retries the request if the connection is lost.
4. **Validation**: Both the client and server perform validation of inputs to ensure that only valid data is processed.

## Changes for UDP Protocol

If we switched from TCP to UDP, the following changes would be required:
1. **Connectionless Communication**: Unlike TCP, UDP does not establish a persistent connection. Therefore, the server would need to handle each request independently, without maintaining an ongoing connection to the client.
2. **Error Handling**: UDP does not guarantee delivery or order of packets. The client and server would need to implement their own error-checking mechanism, such as sending acknowledgment packets or implementing retransmission strategies for lost data.
3. **State Management**: Since UDP is connectionless, both the client and server would need to send all necessary state information with each packet (e.g., the current guess and the current game state).
4. **Packet Size Limits**: UDP packets have a size limit (usually 64KB). The game data would need to be split into smaller packets if the data size exceeds this limit.
5. **Performance Considerations**: UDP could improve performance in certain scenarios by reducing overhead (no connection setup, no acknowledgment required). However, it would also increase the likelihood of losing data, so we would need to implement additional handling for packet loss.
